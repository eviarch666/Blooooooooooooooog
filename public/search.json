[{"title":"FOC理论准备","url":"/2025/06/26/FOC%E7%90%86%E8%AE%BA%E5%87%86%E5%A4%87/","content":"前言\n\n  \n    \n      Warn\n\n    \n    \n      作者本人也是在网上找资料学习的这部分内容，如有错误还请指正。本文中有对其他作者的文章的引用说明，如有忘记声明处还请大家指出。这里也非常推荐大家去看看稚晖君的教程，写得非常详尽，本文也有多处地方引用此文章的语句。\n\n    \n  \n电机的机械角度和电角度\n由硬件篇电机部分所描述的，极数的差异而产生了机械角度和电角度（电周期）的概念。机械角度”就是电机旋转一圈的空间几何角度。转子轴从某个位置开始旋转并返回到原位置的角度是360度。而电角度则是将对绕组（线圈）施加电压的开关的一个切换周期视为360度。\n\n如果是2极3槽的电机，那么其机械角度和电角度是一致的。而如果是4极6槽，则其机械角度是360度，其电角度是两个周期（也可以表达为“当机械角度为180度时，电角度达到360度”，或者说“在一个电周期内转子只转半圈”）。\n\n对于电机的编码器，其角度都是来表示转子的机械角度位置。而电机驱动器输出的电信号则是基于电角度的，因为电信号源于开关一个切换周期的反复。角度的概念已经变得非常重要，所以我们需要清楚地了解这些概念以及它们之间的关系。\n无刷电机控制方式和差异\n六步换相\n无刷电机的六步换相（Six-Step\nCommutation）是一种经典的控制方式，主要用于三相无刷直流电机（BLDC）。它也被称为梯形波控制（Trapezoidal\nCommutation），因其电压或电流波形呈梯形得名。\n六步换相的工作方式\n三相BLDC电机有3根绕组（A、B、C），电机驱动器每次只通电两相，悬空一相，电流在6个步骤中按顺序换相，从而驱动电机旋转。每个电周期（Electrical\nCycle）中包含6个换相步骤，每步持续60电角度，因此称为“六步”。\n\n\n\n步骤\nA相\nB相\nC相\n\n\n\n\n1\n+\n-\nZ\n\n\n2\n+\nZ\n-\n\n\n3\nZ\n+\n-\n\n\n4\n-\n+\nZ\n\n\n5\n-\nZ\n+\n\n\n6\nZ\n-\n+\n\n\n\n\n说明：+为上桥导通，-为下桥导通，Z为高阻/不通电\n\n\n优点：控制算法简单，成本低\n缺点：精度差，运行不一定流畅平滑，该控制方式很难做到对电机的电流（力矩），位置做到闭环控制。采用方波控制，噪声较大。\n\nFOC（Field-Oriented\nControl）控制\n\n优点：转矩平稳，噪声小，响应快速。可以进行电流（力矩）、速度、位置三个闭环控制。\n缺点：成本高，控制算法难度大\n\nFOC控制原理\n对于FOC控制过程来说，最重要的就是对电机相电流的变换和反变换。\n关键前置知识\nPWM, SPWM, SVPWM\nPWM（Pulse Width\nModulation 脉冲宽度调制）\n按一定规律改变脉冲序列的脉冲宽度，以调节输出量和波形的一种调制方式。PWM是脉冲宽度调制也就是具有一定脉冲宽度的连续的方波组成。\nSPWM（Sinusoidal PWM\n正弦脉宽调制）\n该技术是基于PWM的，是对脉冲宽度进行正弦规律排列的调制方式。这样其输出可以近似为正弦波。\n其产生的方式为正弦波和三角波相交而成，其中正弦波相当于调制波，三角波相当于载波，其生成过程如下图。\n这里我们要注意，三角波（载波）的振幅要大于正弦波（调制波）的振幅，否则正弦波的波峰和波谷就会被“削去”。\nSVPWM（Space\nVector Pulse Width Modulation 电压空间矢量PWM）\nSVPWM和SPWM虽然名字很像，但是其时没有很大的关系。SPWM着重于生成一个可以近似于正弦波的PWM波，对于电机控制来说其关注点只在于它自己需要调制的那个正弦波。而SVPWM则是关注于电机整体，使得输出电压波形尽可能接近于理想的正弦波形，着眼于如何使电机获得理想圆形磁链轨迹！要了解SVPWM就得先了解什么是空间电压矢量。\n首先我们要看逆变器的电路原理图：\n\n\nInverter_Circuit\n\n为了便于理解，我们将PMSM的线圈展开绘制出来：\n\n\nInverter_Circuit_with_Coil\n\nSVPWM算法实际上计算的是上图所示逆变器的六个开关何时导通，何时切断。我们可以看到这六个开关管是两两一组的，也就是形成了三组。对于每一组开关管，与VD高电位相连的我们称之为上桥臂，而与VD的低电位相连的我们称之为下桥臂，每一组这个整体我们称之为半桥。\n而对于每一个半桥都有两个状态：\n\n上桥臂导通，下桥臂截止（定义为状态1）\n下桥臂导通，上桥臂截止（定义为状态0）\n\n三个半桥就有23个状态，也就是000、001、010、011、100、101、110、111\n\n空间电压矢量：我们将上述的三个桥的状态的组合就定义为空间电压矢量Un = (Sa, Sb, Sc)。之中有6个非零矢量和2个零矢量（U0 = (0, 0, 0),  U7 = (1, 1, 1)）可以看出零矢量状态下电机三相间电压都为0不产生转矩。我们将矢量画在ABC坐标系下（也就是由三相电流组成的坐标系中）\n\n\n\nSpace_Vector_Diagram\n\n\n其中，V1(1, 0, 0)与IA相同，V3(0, 1, 0)与IB方向相同，V5(0, 0, 1)与IC方向相同。\n\n它们的端点组成了一个正六边形，同时把平面划分成了六个扇区（也就是图中的（1）、（2）、（3）、（4）、（5）、（6））在每一个扇区，选择相邻两个电压矢量以及零矢量，按照伏秒平衡原则来合成每个扇区内的任意电压矢量。这也正是源自于PWM的核心思想，合理地配置不同基向量在一个周期中的占空比，就可以合成出等效的任意空间电压矢量\n∫0TUrefdt = ∫0TxUxdt + ∫TxTx + TyUydt + ∫Tx + TyTU0*dt\n写成离散表达式如下： Uref ⋅ T = Ux ⋅ Tx + Uy ⋅ Ty + U0* ⋅ T0*\n\nU0*指的是两个零矢量，可以是U0也可以是U7，零矢量的选择比较灵活，通过合理地配置零矢量可以让空间电压矢量的切换更平顺，可最大限度地减少开关次数，尽可能避免在负载电流较大的时刻的开关动作，最大限度地减少开关损耗。\n\n\n调制方式：\n\n七段式调制（7-segment SVPWM）\n零矢量对称分布在电压矢量序列的两端，一共7个开关动作，每个周期中相同的矢量对称出现。例如：V0 → V4 → V6 → V7 → V6 → V4 → V0\n优点：谐波小，对称性好，实现简单也最常用\n\n\n\nUref所在扇区\n开关切换顺序\n\n\n\n\n（1）区\n0-4-6-7-6-4-0\n\n\n（2）区\n0-2-6-7-6-2-0\n\n\n（3）区\n0-2-3-7-3-2-0\n\n\n（4）区\n0-1-3-7-3-1-0\n\n\n（5）区\n0-1-5-7-5-1-0\n\n\n（6）区\n0-4-5-7-5-4-0\n\n\n\n五段式调制（5-segment SVPWM）\n零矢量只在一端使用（只用 V0 或\nV7），不对称，省略了一端的零矢量插入。例如：V4 → V6 → V7 → V6 → V4\n优点：开关频率低\n缺点：谐波较高\n九段式调制（9-segment SVPWM）\n零矢量插入在三处：前、中、后，用更多零矢量来均衡电压和磁链。例如：V0 → V4 → V0 → V6 → V7 → V6 → V0 → V4 → V0\n该方法使用很少，开关频率最高，损耗也最大，控制逻辑也复杂\n\n更多调制方式可以阅读相关文献，这里不再深入探讨。\n\nClark变换，Park变换，反Park变换\nClark变换\n三相电路计算困难，将三相等效成二相。根据基尔霍夫电流定律（KCL）：任意时刻流入节点的电流和等于流出节点的电流和。因此我们只需要知道其中两个电流就可以推导出第三相的电流。其变换过程和变换矩阵如下：\n 比例系数K的值为\n，则转换矩阵为： \n\nK为何是？\nClark\n变换的矩阵本身并不保持矢量长度（不是正交变换），所以变换前后的矢量模长（幅值）会变化。为了让变换前后的幅值不变，就需要再乘一个比例系数。\n若要进行等功率Clark变换则\n若想更深入了解可查看这篇文章\n\n经过如上Clark变换，就成功将三相电流变为了新的两相电流，但对于控制两相正弦波电流来说仍然是一件困难的事情。\nPark变换\n若要将正弦的两个变量转为常量来控制，则需要让坐标系跟着两个变量一起旋转。也就是坐标系和新的两相电流的矢量相对静止了（这么表述肯定不严谨，但是最本质的思想是这个意思）。其变换过程如下：\n 接下来我们就可以对Id和Iq来进行控制了，经过如上变换将大大降低我们对电流控制的难度。而这两个量所代表的物理意义为转子旋转的径向和切向这两个方向的变量。其中：Iq为切向电流分量，Id为径向电流分量，我们也需要尽力把它控制为0，\n反Park变换\n即为Park变换的逆变换 \nFOC控制流程\n先附上FOC控制流程的PID环\n\n\nFOC_PID_White\n\n\n图片中Target开头的代表设定值，即用户希望的值的大小\n\n该PID是常见的位置-速度-电流三环控制，其中位置可以只用P项或者PI项。在位置控制中，由于电机转速很低，所以编码器微分得到的角速度不一定准确，因此往往去掉速度环而直接使用位置-电流双环控制。可以看到，前文的知识点都是在为FOC控制的电流环服务的，由此可见电流环的重要程度非常高。\n","categories":["Hardware","Motor","Motor Control"],"tags":["Hardware","FOC","SVPWM","Motor drive","PID"]},{"title":"IMU四元数解算","url":"/2025/06/10/IMU%E5%9B%9B%E5%85%83%E6%95%B0%E8%A7%A3%E7%AE%97/","content":"前言\n\n  \n    \n      Warn\n\n    \n    \n      本文章有基础的理论推导，过程可能存在不严谨的地方，着重对四元数的实际应用做讨论\n此文章的观点或代码仍有瑕疵，若您有更好的解决方案或更正建议欢迎留言讨论\n\n    \n  \n\n  \n    \n      info\n\n    \n    \n      本文前部分是关于理论推导，内容比较枯燥。若只关注实际应用请跳转到后文，查阅相关代码\n本文的代码已通过验证，MCU为AI8051，IMU为imu660ra。角速度通过死区 +\n去静态零飘抑制。实际测试静态零漂约为0.046度/秒\n\n    \n  \n关于四元数的介绍和理解\n四元数的产生\n对于一个复数，可以写成如下形式  ,运用欧拉公式(Euler’s formula) ρeiα = ρcos α + iρsin α\n可将三角函数形式的复数转为指数形式 z = ρeiα\n对该复平面内的向量进行旋转操作，假设旋转角度为ϕ,则旋转过程如下:\n\n该旋转为一个自由度下的变化，对于实际应用来说，一个物品在空间中的矢量有三个自由度。因此我们需要四个变量来描述角度的变化，其中一个实数变量表示旋转的角度大小，剩下三个为虚数，体现旋转轴的方向。我们将这样的四个变量记作：\nq = (w, x, y, z)\n对于一个旋转角度为θ的四元数可表示为： \n\n实部（w）：与旋转的角度相关，体现旋转的“量”。\n虚部（x, y,\nz）：与旋转轴的方向相关，体现旋转的“方向”。\n\n为了方便，我们有时将其简写为：  其中 \n这也就是我们常说的轴角对：\n\n旋转轴：一个单位向量，表示旋转的轴线方向。\n旋转角：一个标量，表示绕该轴旋转的角度。\n\n用四元数表示3D旋转矩阵\n并不是所有的四元数都能表示三维空间中的一个旋转，只有单位四元数才能正确表示一个旋转。所谓单位四元数即：\n满足 对一个3D向量：  其旋转后的向量可表示为： \n计算旋转矩阵\n(1)计算q⋅p\n设：  则  记  (2) 计算 (q⋅p)⋅q−1 所以：展开后为： (3)整理成矩阵形式\n将a,b,c,d代入上方程组中，可整理出旋转矩阵：  \n  \n    \n      info\n\n    \n    \n      该旋转矩阵较为重要，在本文后续还会用到\n\n    \n  \n\n四元数的关键公式推导\n\n四元数和角速度的关系\n对于给定一个角速度，我们需要找到四元数如何随时间变化。角速度\nω 描述了旋转的变化率。四元数的导数 q’\n可以通过以下方式与 ω 关联：\n设角速度为： ω = [ωx, ωy, ωz]\n\n对于一个旋转矩阵 R(t)，其时间导数满足： 其中，为的反对称矩阵\n四元数的倒数\n通过微分 R 并利用\nR=[ω]×R，可以推导出四元数的导数\nq’。这个过程涉及大量的代数运算，最终得到： 其中是一个纯四元数（无实部），表示为：\n\n\n\n从角速度到四元数\n假设当前四元数为q = (w, x, y, z),角速度为ω = (0, ωx, ωy, ωz),则四元数倒数为：\n ，展开运算可得： \n这些导数被用来更新四元数的各个分量，然后进行归一化处理，将会被用于后续的代码中\n\n关于欧拉角的介绍和理解\n什么是欧拉角\n欧拉角是一种直观描述物体在三维空间中姿态（Orientation）\n的方法，通过绕三个相互垂直的坐标轴依次旋转来表示。最常用的是\n俯仰角（Pitch）、偏航角（Yaw）、翻滚角（Roll）\n系统。\n三个旋转轴： 在物体自身坐标系中定义：\n\nX轴（翻滚轴）：指向物体正右方（如飞机右翼方向）。\nY轴（俯仰轴）：指向物体正前方（如飞机机头方向）。\nZ轴（偏航轴）：指向物体正上方（如飞机顶部方向）。\n\n\n注意：必须按固定顺序旋转（如 Z→Y→X\n或 Y→X→Z），不同顺序会得到不同结果。\n\n此处我们使用ZYX顺序的旋转矩阵，旋转矩阵 RR\n由三个基本旋转矩阵相乘得到：\n\n则最终R为： \n读者看到这么长的旋转矩阵可能会大脑发怵，这么长的矩阵，这么多三角函数应该怎么去使用呢？对此不必担心，因为我们只需要用到该矩阵的一部分元素。相信读者应该注意到四元数也有一个旋转矩阵，我们就要用四元数求出欧拉角。\n从四元数到欧拉角\n为了方便表示，设旋转矩阵中的元素为： \n\n计算俯仰角θ（Pitch）:\n从 RR 的第三行第一列 r31=−sin⁡θ，得：θ = arcsin (−r31)\n计算偏航角ψ（Yaw）：\n从 RR 的第一行和第二行的第一列：ψ = atan2(r21, r11)\n\n  \n    \n      info\n\n    \n    \n      其中 atan2(y,x)atan2(y,x) 是四象限反正切函数。\n\n    \n  \n计算翻滚角ϕ（Roll）：\n从 RR 的第三行第二列和第三列：θ = atan2(r32, r33)\n\n恭喜各位读者，到此时已完成了理论部分的学习，接下来是应用的部分。因为主要应用在于IMU的角度解算，所以我给出了C语言代码。\n\n实际应用于代码中\n初始化四元数，读取IMU的角速度值\n// 四元素参数初始化，需加入staic，保证变量的生命周期static float q_w = 1.0f;static float q_x = 0.0f;static float q_y = 0.0f;static float q_z = 0.0f;//辅助变量float qa, qb, qc;float gx = DEG_TO_RAD(imu_trans_data.GTX); // 单位需转为rad/s;float gy = DEG_TO_RAD(imu_trans_data.GTY);float gz = DEG_TO_RAD(imu_trans_data.GTZ);\n计算四元数的倒数，并积分求得四元数\n// 四元数导数计算gx *= (0.5f * T);     // 预乘以减少操作，其中T代表代码执行的周期gy *= (0.5f * T);gz *= (0.5f * T);qa = q_w;qb = q_x;qc = q_y;q_w += (-qb * gx - qc * gy - q_z * gz);q_x += (qa * gx + qc * gz - q_z * gy);q_y += (qa * gy - qb * gz + q_z * gx);q_z += (qa * gz + qb * gy - qc * gx);\n将四元数进行归一化\n单位四元数才能正确表示一个旋转，我们需要单位四元数才能求解出欧拉角\n// 归一化四元数recipNorm = 1.0f / sqrt(q_w * q_w + q_x * q_x + q_y * q_y + q_z * q_z);q_w *= recipNorm;q_x *= recipNorm;q_y *= recipNorm;q_z *= recipNorm;\n计算欧拉角\n我们已经获得单位四元数了，根据上文的转换公式可以求得欧拉角\n// 计算欧拉角euler_angle.Roll = RAD_TO_DEG(atan2(2.0f * (q_w * q_x + q_y * q_z), 1.0f - 2.0f * (q_x * q_x + q_y * q_y)));euler_angle.Pitch = RAD_TO_DEG(asin(2.0f * (q_w * q_y - q_z * q_x)));euler_angle.Yaw = RAD_TO_DEG(atan2(2.0f * (q_w * q_z + q_x * q_y), 1.0f - 2.0f * (q_y * q_y + q_z * q_z)));\n到此，我们已经完成了基础的IMU四元数解算，并且求得了欧拉角的值。\n\n代码改进\n普通IMU，例如MPU6050会提供六个数据，分别是三轴的加速度和三轴的角速度。读者可以看到，上述文章中只使用了三轴的角速度，而没有使用三轴的加速度。我们可以用三轴的加速度来修正角速度误差。本文将采用Mahony互补滤波算法，通过加速度计数据修正陀螺仪的角速度误差。重力方向的测量值（来自加速度计）与当前姿态估计的重力方向之间的误差来校正陀螺仪的漂移。接下来我将直接写出完整的代码，方便各位读者使用。\n/** * @brief 四元素法+动态互补滤波s * @note 更大的浮点计算量 *  */void IMU_Get_EularAngle_Plus(void){    // 四元素参数    static float q_w = 1.0f;    static float q_x = 0.0f;    static float q_y = 0.0f;    static float q_z = 0.0f;    // 控制器参数    static const float imu_Kp = 2.0f;    // 比例增益    static const float imu_Ki = 0.005f;  // 积分增益    static float integralFBx = 0.0f, integralFBy = 0.0f, integralFBz = 0.0f;    // 将原始数据转换为弧度每秒和g    float ax = imu_trans_data.ATX;    float ay = imu_trans_data.ATY;      float az = imu_trans_data.ATZ;    float gx = DEG_TO_RAD(imu_trans_data.GTX); // 转为rad/s;    float gy = DEG_TO_RAD(imu_trans_data.GTY);    float gz = DEG_TO_RAD(imu_trans_data.GTZ);    // 辅助变量    float recipNorm;    float halfvx, halfvy, halfvz;    float halfex, halfey, halfez;    float qa, qb, qc;    // 加速度计数据校验    if(ax*ay*az == 0) return;    // 归一化加速度计测量值（必须先归一化）    recipNorm = 1.0f / sqrt(ax * ax + ay * ay + az * az);    ax *= recipNorm;    ay *= recipNorm;    az *= recipNorm;    // 估计重力的方向    halfvx = q_x * q_z - q_w * q_y;    halfvy = q_w * q_x + q_y * q_z;    halfvz = q_w * q_w - 0.5f + q_z * q_z;    // 误差是估计方向和测量方向的叉积    halfex = (ay * halfvz - az * halfvy);    halfey = (az * halfvx - ax * halfvz);    halfez = (ax * halfvy - ay * halfvx);    // 计算并应用积分反馈    if(imu_Ki &gt; 0.0f) {        integralFBx += imu_Ki * halfex * halfT;    // 积分误差比例增益        integralFBy += imu_Ki * halfey * halfT;        integralFBz += imu_Ki * halfez * halfT;        gx += integralFBx;    // 应用积分反馈        gy += integralFBy;        gz += integralFBz;    } else {        integralFBx = 0.0f;   // 防止积分饱和        integralFBy = 0.0f;        integralFBz = 0.0f;    }    // 应用比例反馈    gx += imu_Kp * halfex;    gy += imu_Kp * halfey;    gz += imu_Kp * halfez;    // 四元数导数计算    gx *= (0.5f * halfT);     // 预乘以减少操作    gy *= (0.5f * halfT);    gz *= (0.5f * halfT);    qa = q_w;    qb = q_x;    qc = q_y;    q_w += (-qb * gx - qc * gy - q_z * gz);    q_x += (qa * gx + qc * gz - q_z * gy);    q_y += (qa * gy - qb * gz + q_z * gx);    q_z += (qa * gz + qb * gy - qc * gx);    // 归一化四元数    recipNorm = 1.0f / sqrt(q_w * q_w + q_x * q_x + q_y * q_y + q_z * q_z);    q_w *= recipNorm;    q_x *= recipNorm;    q_y *= recipNorm;    q_z *= recipNorm;    // 存储四元数    quaternion.qw = q_w;    quaternion.qx = q_x;    quaternion.qy = q_y;    quaternion.qz = q_z;    // 计算欧拉角    euler_angle.Roll = RAD_TO_DEG(atan2(2.0f * (q_w * q_x + q_y * q_z), 1.0f - 2.0f * (q_x * q_x + q_y * q_y)));    euler_angle.Pitch = RAD_TO_DEG(asin(2.0f * (q_w * q_y - q_z * q_x)));    euler_angle.Yaw = RAD_TO_DEG(atan2(2.0f * (q_w * q_z + q_x * q_y), 1.0f - 2.0f * (q_y * q_y + q_z * q_z)));}\n","categories":["Hardware","Sensor","Sensor Drive"],"tags":["Hardware","Eular Angle","Quaternion"]},{"title":"基础排序算法","url":"/2025/06/10/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":"\n对一些排序算法做个归纳\n持续更新\n\n算法性能评估术语\n\n\n稳定：如果a原本在b前面，而a=b时，排序之后a仍然在b的前面。\n不稳定：如果a原本在b的前面，而a=b时，排序之后a可能出现在b的后面。\n内排序：所有排序操作都在内存中完成。\n外排序：通常是由于数据太大，不能同时存放在内存中，根据排序过程的需要而在外存与内存之间\n数据传输才能进行。\n时间复杂度：时间频度，一个算法执行所耗费的时间。算法中通常用数据比较次数与数据移动次数\n进行衡量。\n空间复杂度：算法执行所需要的内存大小。\nIn-place：占用常数内存，不占用额外内存\nOut-place：占用额外内存\n\n\n\n冒泡排序\n说明\n\n\n冒泡排序\n\n\n最基础的排序\n算法的每⼀轮都是从左到右来⽐较元素， 进⾏单向的位置交换的\n\n原始代码实现\nvoid bubbleSort(int a[], int n) &#123;\t\t//n为元素个数    for (int i = n - 1; i &gt; 0; i--) &#123;        for (int j = 0; j &lt; i; j++) &#123;            if (a[j] &gt; a[j + 1])                swap(a[j], a[j + 1]);        &#125;    &#125;&#125;\n原始代码性能分析\n\n\n最佳时间复杂度：O(N)\n最差时间复杂度：O(N2)\n平均时间复杂度：O(N2)\n空间复杂度：O(1)\n排序方式：In-place\n稳定性：稳定\n\n\n代码优化\n函数模板\ntemplate&lt;typename T,int len&gt;void bubbleSort(T (&amp;arr)[len])&#123;    for (int i = len-1; i &gt; 0; --i) &#123;        for (int j = 0; j &lt; i; ++j) &#123;            if (arr[j] &lt; arr[j+1])&#123;                T t = arr[j];                arr[j] = arr[j+1];                arr[j+1] = t;            &#125;        &#125;    &#125;&#125;\n直接传入数组指针时无法用sizeof函数，故使用引用的方式\n设置排序完成的标志\n\n冒泡排序需要有两层循环，无论数组是否排好序，都会完成这两层循环，对于最差的情况，比如[9,8,7,6,5,4]，对其进行升序排序，这两层循环必不可少；但是对于[9,1,2,3,4,5]这种情况，第一遍循环结束后，整个数组就已经是升序排列的了，但是普通的冒泡排序还会继续进行循环遍历比较，这就对做了不少无用功。所以需要设置一个排序完成的标志，如果排序已经完成，就没必要再继续循环遍历了，直接跳出循环。\n\ntemplate&lt;typename T,int len&gt;void bubbleSort(T (&amp;arr)[len])&#123;    bool isSwapped;\t\t\t//判段是否进行过排序，若没排序过则直接跳出循环    for (int i = len-1; i &gt; 0; --i) &#123;        isSwapped = false;        for (int j = 0; j &lt; i; ++j) &#123;            if (arr[j] &gt; arr[j+1])&#123;                T t = arr[j];                arr[j] = arr[j+1];                arr[j+1] = t;                isSwapped = true;            &#125;        &#125;        if (!isSwapped)break;    &#125;&#125;\n\n鸡尾酒排序\n说明\n\n\n鸡尾酒排序\n\n\n鸡尾酒排序是冒泡排序的优化\n排序过程就像大摆锤一样，第一轮从左到右，第二轮从右到左，第三轮再从左到右…\n\n原始代码实现\nvoid Cocktail_Sort(int arr[], int sz)&#123;\tint tmp = 0;\tint left = 0;\tint right = sz - 1;\tfor (int i = 0; i &lt; sz / 2; i++)\t&#123;\t\t//有序标记，每一轮的初始是true\t\tbool flag = true;\t\t//奇数轮，从左向右比较和交换\t\tfor (int j = 0; j &lt; sz - i - 1; j++)\t\t&#123;\t\t\tif (arr[j] &gt; arr[j + 1])\t\t\t&#123;\t\t\t\ttmp = arr[j];\t\t\t\tarr[j] = arr[j + 1];\t\t\t\tarr[j + 1] = tmp;\t\t\t\t//有元素交换，所以不是有序，标记变为0\t\t\t\tflag = false;\t\t\t&#125;\t\t&#125;\t\tif (flag) break;\t\t//偶数轮之前，重新标记为1\t\tflag = true;\t\t//偶数轮，从右向左比较和交换\t\tfor (int j = sz - i - 1; j &gt; i; j--)\t\t&#123;\t\t\tif (arr[j] &lt; arr[j - 1])\t\t\t&#123;\t\t\t\ttmp = arr[j];\t\t\t\tarr[j] = arr[j - 1];\t\t\t\tarr[j - 1] = tmp;\t\t\t\t//有元素交换，所以不是有序，标记变为0\t\t\t\tflag = false;\t\t\t&#125;\t\t&#125;\t\tif (flag) break;\t&#125;&#125;\n原始代码性能分析\n\n鸡尾酒排序是冒泡排序的一种改进，倒并未有本质的改变，与冒泡排序的时间复杂度和空间复杂度相近，整体的性能都比较差。\n\n最佳时间复杂度：O(N)\n最差时间复杂度：O(N2)\n平均时间复杂度：O(N2)\n空间复杂度：O(1)\n排序方式：In-place\n稳定性：稳定\n\n\n","categories":["Algorithm","Sorting Algorithms"],"tags":["Cpp","Sequence","Algorithm"]},{"title":"学习思路","url":"/2025/06/30/%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/","content":"起因是由于快到暑假了，我的一个非常好的朋友向我询问假期该学什么东西，于是我写了一个小短篇来记录一部分技术栈。本着充分利用的原则，正好水一篇博客\n😝\n单片机科技树（下位机）\n\ngit一定是要学的，只要你要码代码。代码版本管理工具，只要是项目都得用这个管理，要不然就是在裸奔，哪天项目炸了都没法救。\n温习一下C语言语法，特别是字符串处理部分，毕竟C语言没有字符串这个变量类型，取而代之的字符型数组。\n跟着江科大的视频学习，建议学到10-5章节，硬件IIC读写MPU6050.【STM32入门教程-2023版\n细致讲解\n中文字幕】https://www.bilibili.com/video/BV1th411z7sn?vd_source=ae3664be1e1799f07dac1218a5638e00\n多学习一些传感器，陀螺仪，编码器，红外感应，超声波，数码管，舵机i，有刷电机，无刷电机（电调，FOC（也就是我现在在学的））\n进阶路径：了解MCU内部组成，寄存器之类的。了解中断原理，任务调度，写一个完整的项目。要学会阅读芯片手册，建议从中文手册开始，毕竟是母语，看得懂一些。\n\n嵌入式科技树（上位机）\n\nLinux，没什么好说的，几乎所有的卡片电脑（下面简称为派）都使用这类系统。学会基本的安装系统，命令行操作（bash脚本或许会用到），基本的文件组成结构。一般来说，第三方资源最多的是树莓派，之前也见到过，还挺贵的说实话，不过价格比之前好多了。推荐学习Ubuntu，别问为什么，问就是其他厂商一般只做这个系统适配。\n命令行该学哪些：首先是包管理器，对于小白来说最容易出问题的部分，比如我刚入门的时候只update，不upgrade。结果就是只更新了缓存，而没更新实际的软件包。要摒弃掉Windows系统的图形化界面操作，虽然一开始很不适应。基础的文件操作、权限修改命令。\nC 语言，Python 上位机对下位机的控制程序在这里实现，我一般用Python，C\n我不太了解。一般来说派的厂商会提供GPIO的库之类的，再辅以OpenCV之类的，就可以完成基础的视觉任务了，但是对于进阶任务得学yolov5，这部分我不推荐现在学习\n例如树莓派这类的电脑，官方会提供一些命令，通常是操作某些特殊硬件的入口，例如CSI和DSI这类外设，其他的使用和普通Linux电脑无异。\n\n工具类科技树\n\ngit，远端git仓库（GitHub）\nmarkdown 做笔记用，超级轻量级的语法。例如：https://obsidian.md/\nvscode 号称万能的代码编辑器，也可以用来写markdown，只要你想。\n梯子 不必多说\nAI 帮你高效解决问题的好工具\n了解计算机系统部分的知识，或许没有直接用处，但是可以提升你的知识素养，没准哪天你就知道你想干啥了呢。\n\n\n最后写点：上面的只是我推荐的东西，实际需要什么，实际你想学什么，我都不知道，这也仅仅是一部分技术栈罢了。\n","categories":["Short post","Learning","Learning Path"],"tags":["Short post","Learning Path"]},{"title":"潜水最优策略","url":"/2025/06/10/%E6%BD%9C%E6%B0%B4%E6%9C%80%E4%BC%98%E7%AD%96%E7%95%A5/","content":"题目\n一支队伍由n个人组成．在潜水时必须使用氧气瓶，但是每支队伍只有一个氧气瓶．最多两个人同时使用一个氧气瓶，但此时两人必须同步游泳，因此到达河对岸的时间等于较慢的一个单独游到终点所需要的时间．好在大家都很友好，因此任何两个人都愿意一起游泳．安排一种潜水策略，使得最后一名选手尽早到达终点。\nInput\n先输入一个整数n，表示队伍中人数，再依次输入每个人游到对岸所需时间（乱序）\nOutput\n输出队伍到达河对岸最少的时间\n\n\n\nSample Input\nSample Output\n\n\n\n\n3 1 3 4\n8\n\n\n6 1 2 5 6 8 9\n27\n\n\n\n算法\n采用贪心算法的思想\n\n\n在总人数（n）一定的前提下，过河次数也一定(2*n-3)\n每次将最慢的两个人搭配在一起，以保证节约的时间最多\n每次来回送氧气瓶由最快的两人负责\n\n\n\n每一组开始的时候是最快的两个人过去\n然后其中一人送瓶子回来\n然后最慢两人过去\n最后第二个快的人送瓶子回来\n\n想法确定，我打算先列出几个例子，浅浅验证一下想法:（例子中已从小到大排好顺序）\n\n\n测试样例\n\n可以看到四个为一组，每一组分别为：第二人、第一人、每一次中最慢的人、第二人。其中每一组第三个人（也就是每一次最慢的人）的规律为从后往前的奇数位。\n代码实现：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123;    //input part    int n;    cin&gt;&gt;n;    int arr[100];    for (int i = 0; i &lt; n; ++i) &#123;        cin&gt;&gt;arr[i];    &#125;        if (n == 1)&#123;\t//special process for only one people        cout&lt;&lt;arr[0];        return 0;    &#125;    sort(arr,arr+n);    int count = 2*n-3;  //times of crossing river    int time = 0;       //the time used to cross river    int control=0;      //used to choose the lowest person    for (int i = 1; i &lt;= count; i++) &#123;        int select = i % 4;     //four people compose a routine        switch (select) &#123;            case 1:time += arr[1];                break;            case 2:time += arr[0];                break;            case 3:time += arr[n-1-control];                control += 2;                break;            case 0:time += arr[1];                break;        &#125;    &#125;    cout&lt;&lt;time;    return 0;&#125;\n最后要说明一下，对于只有一个人的情况我单独处理了\n","categories":["Algorithm","Best Solution"],"tags":["Cpp","Algorithm","Best solution"]}]